# 3CX-DATEV Bridge — Developer Guide

## Why This Application Exists

3CX V20 migrated from WinForms/.NET Framework to WinUI 3/.NET 9.0 and **removed the legacy plugin system** (MyPhonePlugins). This broke all existing DATEV CTI integrations that relied on the plugin interface.

This standalone proxy application restores DATEV integration by:

1. Monitoring calls via the Windows **TAPI 2.x API** (the 3CX Multi-Line TAPI driver still exposes this)
2. Sending commands to 3CX via **Named Pipes** (the TAPI Service Provider's pipe interface)
3. Communicating with DATEV via the **COM/ROT Buddy interface** (unchanged since DATEV SDK 2022)

The bridge is intentionally a separate process rather than a plugin because there is no plugin system to hook into.

---

## DATEV Buddy Interface

The bridge implements the **DATEV CTI Buddy SDK** (version 16.02.2022). This is a COM-based interface defined in `DatevCtiBuddy.tlb`.

### Interface Map

| IDL Interface | Implemented By | Role |
|---------------|----------------|------|
| `IDatevCtiControl` | `DatevAdapter.cs` (Bridge) | DATEV calls `Dial()` and `Drop()` on the bridge |
| `IDatevCtiHistory` | `DatevAdapter.cs` (Bridge) | DATEV calls `GetCallData()` (not used per spec) |
| `IDatevCtiNotification` | DATEV Telefonie | Bridge calls `NewCall()`, `CallStateChanged()`, `CallAdressatChanged()`, `NewJournal()` |
| `IDatevCtiData` | Both sides | Data transfer object for call information (11 properties) |

### COM Class Registration (ROT)

Neither class is registered in the Windows registry. Both use the **Running Object Table** for discovery:

| Class | CLSID | Registered By |
|-------|-------|---------------|
| `DatevTelefonie` | `A299D197-E7C3-43E2-8ACC-C608FC2A7806` | DATEV Arbeitsplatz |
| `BuddyAdapter` | `D8CA0C15-8585-494A-93DF-07D706629793` | This bridge (`AdapterManager.cs`) |

The bridge registers `BuddyAdapter` in ROT at startup and removes it at shutdown. DATEV looks up the bridge via `GetActiveObject()` with the BuddyAdapter CLSID.

### IDatevCtiData Properties

| ID | Property | Type | Notes |
|----|----------|------|-------|
| 1 | `CallID` | BSTR | Generated by bridge, never empty, unique per call |
| 2 | `SyncID` | BSTR | Set exclusively by DATEV, must not be stored in journal |
| 3 | `Direction` | ENUM_DIRECTION | `eDirIncoming` or `eDirOutgoing` |
| 4 | `Begin` | DATE | Call start time (Offered) or connect time (Connected/Finished) |
| 5 | `End` | DATE | Always >= Begin. Disconnect time when Finished |
| 6 | `CallState` | ENUM_CALLSTATE | `eCSOffered`, `eCSConnected`, `eCSFinished`, `eCSAbsence` |
| 7 | `Adressatenname` | BSTR | Contact display name |
| 8 | `AdressatenId` | BSTR | Contact ID from DATEV SDD |
| 9 | `DataSource` | BSTR | `DATEV_Adressaten`, `DATEV_Institutionen`, or `3CX` |
| 10 | `CalledNumber` | BSTR | Remote party's phone number (regardless of direction) |
| 11 | `Note` | BSTR | Call note (journal only) |

### CallState Transition Rules

The DATEV spec defines strict valid transitions:

```
Offered → Connected → Finished     (normal answered call)
Offered → Absence                   (missed/unanswered call)
Connected → Finished               (late-arriving call, already connected)
Finished                            (direct, for NewJournal)
Absence                             (direct, for NewJournal)
```

All other transitions are forbidden. The bridge enforces this in `BridgeService.cs` by mapping TAPI states to DATEV states:

| TAPI State | DATEV CallState | Notification |
|------------|----------------|--------------|
| `LINECALLSTATE_OFFERING` | `eCSOffered` | `NewCall()` |
| `LINECALLSTATE_RINGBACK` | `eCSOffered` | `NewCall()` (outgoing) |
| `LINECALLSTATE_CONNECTED` | `eCSConnected` | `CallStateChanged()` |
| `LINECALLSTATE_DISCONNECTED` (was connected) | `eCSFinished` | `CallStateChanged()` |
| `LINECALLSTATE_DISCONNECTED` (never connected) | `eCSAbsence` | `CallStateChanged()` |

### SyncID Contract

The SyncID is critical for DATEV's internal call tracking:

1. **Created exclusively by DATEV** — the bridge never generates a SyncID
2. **Passed via Dial command** — when DATEV initiates a call, SyncID is included
3. **Signaled back at every event** — NewCall, CallStateChanged, CallAdressatChanged all include SyncID
4. **Never stored in journal** — explicitly cleared (`SyncID = string.Empty`) before NewJournal
5. **Only valid during a call** — not persisted across calls

Implementation: `NotificationManager.cs:55` has an explicit comment: "Note: SyncID is NOT set by the bridge — only DATEV Telefonie sets this."

### DataSource Values

| Value | When to Use | Defined In |
|-------|-------------|------------|
| `DATEV_Adressaten` | Contact is a DATEV Recipient (from SDD KontaktDetail) | `DatevDataSource.Recipient` |
| `DATEV_Institutionen` | Contact is a DATEV Institution (from SDD TELEFONIE) | `DatevDataSource.Institution` |
| `3CX` | Contact is not in DATEV (unmatched caller) | `DatevDataSource.ThirdParty` |

Values starting with `DATEV_` are reserved by DATEV. The bridge uses `3CX` for unmatched callers.

---

## DATEV SDD Integration

### Contract Parameters

The bridge loads contacts from the DATEV Stammdatendienst (SDD) using these parameters:

**Recipients (Adressaten):**

```csharp
contractIdentifier = "Datev.Sdd.Contract.Browse.1.2"
dataEnvironment    = "Datev.DataEnvironment.Default"
elementName        = "KontaktDetail"
filterExpression   = @"<FilterExpression>
    <ComparisonExpression operator=""NOT EQUAL TO"">
        <LeftOperand><Field name=""@Status""/></LeftOperand>
        <RightOperand><Literal type=""String"" value=""0""/></RightOperand>
    </ComparisonExpression>
</FilterExpression>"   // only when ActiveContactsOnly=true
```

**Institutions:**

```csharp
contractIdentifier = "Datev.Inst.Contract.1.0"
dataEnvironment    = "Datev.DataEnvironment.Default"
elementName        = "TELEFONIE"
// no status filter
```

### XML Data Mapping

| XML Path | Maps To | Notes |
|----------|---------|-------|
| `KontaktDetail[@ID]` | `AdressatenId` | Not displayed, used as key |
| `KontaktDetail/Kontakt/Langname` | `Adressatenname` | Display name |
| `KontaktDetail/Kontakt/Kommunikationen/Kommunikation/Medium` | `Medium` enum | 1 = Phone (only type loaded) |
| `KontaktDetail/Kontakt/Kommunikationen/Kommunikation/Nummer` | `CalledNumber` | Phone number |
| `KontaktDetail/Kontakt/Kommunikationen/Kommunikation/Notiz` | (displayed in popup) | Phone number note |

The same structure applies to Institutions with `TELEFONIE` as the root element instead of `KontaktDetail`.

### Phone Filtering

Only communications with `Medium == 1` (Phone) are loaded. Email, fax, internet, and other medium types are filtered out in `DatevContactManager.FilterPhoneCommunications()`. This reduces loaded objects from ~68,000 to ~17,000.

---

## Named Pipe Protocol

### Architecture

The bridge is the pipe **server**. The 3CX Softphone connects as **client**.

```
3CX Softphone (Client)  ←→  Bridge (Server)
                              \\.\pipe\3CX_tsp_server_{extension}
```

The 3CX Softphone polls for this pipe every ~2 seconds at startup. On Terminal Server, the pipe must be created before TAPI initialization.

### Wire Format

```
[2 bytes: message length (little-endian uint16)] [N bytes: UTF-16LE message body]
```

Example: A 20-character message has a 4-byte header (length=40 in LE) followed by 40 bytes of UTF-16LE text.

### Message Format

Messages are comma-separated `key=value` pairs:

```
__reqId=1,callid=123,cmd=MAKE-CALL,number=+49891234567
```

Reply pattern: The softphone echoes the original `cmd` with `__answ#` prefix and `reply` fields.

### Protocol Commands

| Direction | Command | Key Fields | Purpose |
|-----------|---------|------------|---------|
| Server→Client | `SRVHELLO` | `cmd` | Handshake initiation |
| Client→Server | `CLIHELLO` | `cmd` | Handshake response |
| Server→Client | `MAKE-CALL` | `cmd`, `number`, `__reqId` | Initiate outgoing call |
| Server→Client | `DROP-CALL` | `cmd`, `callid`, `__reqId` | Hang up active call |
| Client→Server | `RINGING` | `cmd`, `callid`, `callerid` | Incoming call notification |
| Client→Server | `RINGBACK` | `cmd`, `callid`, `callerid` | Outgoing call ringing |
| Client→Server | `CONNECTED` | `cmd`, `callid` | Call connected |
| Client→Server | `DISCONNECTED` | `cmd`, `callid` | Call ended |
| Client→Server | `CALL-INFO` | `cmd`, `callid`, various | Caller/called party info |

### Pipe Security

Access is controlled via Windows DACL on the `NamedPipeServerStream`:

- Current user's SID: `FullControl`
- `ALL APPLICATION PACKAGES` (SID `S-1-15-2-1`): `FullControl` (for MSIX/AppContainer 3CX apps)
- No other access

---

## Call Tracking

### CallID Generation

Format: `{Extension}-{ddMMyyyy}-{HHmm}-{Random7}`

Example: `161-04022026-1430-0912387`

The random suffix ensures uniqueness across restarts (no sequential counter).

Implementation: `CallIdGenerator.Next()` in `Core/CallIdGenerator.cs`.

### Call Record Lifecycle

```
1. OFFERING/RINGBACK
   └── CallTracker.AddCall(tapiCallId, isIncoming)
       └── Creates CallRecord with StartTime, Direction

2. Contact matched
   └── record.CallData populated with DATEV contact info
       └── NotificationManager.NewCall(callData)

3. CONNECTED
   └── record.ConnectTime = DateTime.Now
       └── NotificationManager.CallStateChanged(eCSConnected)

4. DISCONNECTED
   └── record.EndTime = DateTime.Now
       └── NotificationManager.CallStateChanged(eCSFinished or eCSAbsence)
       └── CallTracker.RemoveCall(tapiCallId)
       └── CallHistoryStore.Add(entry) if DATEV-matched
```

### Pending Calls (DATEV Dial)

When DATEV initiates a Dial command, the bridge stores a "pending call" because the TAPI event hasn't arrived yet:

```
1. DATEV Dial received
   └── CallTracker.AddPendingCall(tempId)
       └── Store SyncID, contact info, phone number
       └── Update phone number index for matching

2. TAPI RINGBACK arrives
   └── CallTracker.FindPendingCallByNumber(normalizedNumber)
       └── Match by normalized phone number (O(1) via index)
       └── CallTracker.PromotePendingCall(tempId, tapiCallId)
           └── Pending call becomes active call with preserved DATEV context
```

### Stale Call Cleanup

A timer runs every 60 seconds to clean up stale calls:

- Active calls older than `StaleCallTimeoutMinutes` (default: 240 min) are removed
- Pending calls older than `StalePendingTimeoutSeconds` (default: 300 sec) are removed

---

## Contact Matching

### Normalization Pipeline

```
Input:  "+49 89 12345678"
Step 1: Strip international prefix: "+49" → "49"     → "49 89 12345678"
Step 2: Strip non-digits:                              → "498912345678"
Step 3: Take last MaxCompareLength digits (default 10): → "8912345678"
```

The same normalization is applied to both incoming caller IDs and DATEV contact phone numbers.

### Lookup Strategy

1. **Exact match** — O(1) lookup in `SortedDictionary<string, List<DatevContactInfo>>`
2. **Suffix match** — If no exact match, try suffix matching (min 6 digits overlap):
   - Incoming number ends with stored key (DATEV has shorter number)
   - Stored key ends with incoming number (incoming is shorter)
3. **No match** — Return empty list, DataSource set to `3CX`

### Last-Contact Routing

`ContactRoutingCache` remembers the last-selected contact per normalized phone number:

- On contact selection (initial or reshow), the choice is recorded
- On next call from the same number (within `LastContactRoutingMinutes`), the previous choice is prioritized
- Cache is in-memory only, resets on restart

---

## Error Handling Patterns

### Circuit Breaker

`CircuitBreaker.cs` wraps all DATEV COM calls:

```
Closed → (3 failures) → Open → (30s timeout) → Half-Open → (success) → Closed
                                                           → (failure) → Open
```

This prevents the bridge from hanging on DATEV COM timeouts when DATEV is unavailable.

### Retry with Backoff

`RetryHelper.cs` provides retry logic for SDD operations:

- Attempt 1: Immediate
- Attempt 2: Wait `SddRetryDelaySeconds` (default 1s)
- Attempt 3: Wait `SddRetryDelaySeconds * 2` (default 2s)
- Only transient errors trigger retries

### TAPI Error Categories

`TapiException.cs` categorizes TAPI errors for intelligent handling:

| Category | Action | Examples |
|----------|--------|---------|
| `Success` | Continue | No error |
| `Transient` | Retry with backoff (500ms→1s→2s→4s) | REINIT, RESOURCEUNAVAIL |
| `LineClosed` | Reconnect line | INVALLINEHANDLE |
| `Shutdown` | Full reinitialize | NODRIVER, UNINITIALIZED |
| `Permanent` | Log and fail | INVALAPPHANDLE, OPERATIONFAILED |

---

## Terminal Server Considerations

### Per-Session Isolation

On terminal servers, multiple users run DATEV and the bridge simultaneously. Isolation is provided by the OS:

| Resource | Isolation | Mechanism |
|----------|-----------|-----------|
| ROT | Per-session | Windows ROT is session-scoped (no GUID modification needed) |
| Named Pipe | Per-user | DACL restricts to current user's SID |
| TAPI | Per-session | Each session has its own TAPI driver instance |
| INI Config | Per-user | `%AppData%` resolves to per-user path |
| Log File | Per-user | Written to per-user `%AppData%` |

### Startup Order on Terminal Server

```
1. Bridge creates Named Pipe server (MUST be first)
2. 3CX Softphone detects pipe (polls every ~2 seconds)
3. Bridge initializes DATEV (ROT registration, SDD load)
4. 3CX connects to pipe → handshake (SRVHELLO/CLIHELLO)
5. TAPI events begin flowing
```

The pipe must exist before 3CX polls for it, which is why pipe creation happens before DATEV initialization on Terminal Server.

---

## Design Decisions

### Why TAPI 2.x Instead of Direct 3CX API?

3CX V20 has no public plugin API. The TAPI driver is the only stable interface for call monitoring. It provides reliable call state events without depending on 3CX internal APIs.

### Why Named Pipes Instead of TAPI MakeCall?

The TAPI `lineMakeCall` function can initiate calls, but the 3CX TAPI driver uses a named pipe for command dispatch. The bridge creates a pipe server matching the name 3CX expects (`3CX_tsp_server_{ext}`) and sends commands in the 3CX wire format.

### Why a Single BridgeService Orchestrator?

At ~1,200 lines, `BridgeService.cs` is large but serves as the single orchestration point. The domain logic is delegated to focused managers:

- `CallTracker` — call lifecycle
- `NotificationManager` — DATEV COM calls
- `CallDataManager` — data preparation
- `DatevContactManager` — SDD access
- `CallStateMachine` — state validation

Splitting BridgeService would mainly shuffle code and add inter-class communication without reducing complexity.

### Why COM/ROT Instead of REST/gRPC?

The DATEV Buddy interface is defined by DATEV as a COM/ROT-based interface. There is no alternative. Both DATEV and the bridge register COM objects in the Running Object Table and discover each other via `GetActiveObject()`.

### Why .NET Framework 4.8 Instead of .NET 8+?

The DATEV COM interop libraries (`DATEV.Interop.DatevCtiBuddy.dll`) target .NET Framework. The SDD client libraries (`Datev.Sdd.Data.ClientInterfaces.dll`) are also .NET Framework assemblies. Mixing .NET Framework COM interop with .NET 8+ would require complex bridging.

### Why x86?

The DATEV SDK documentation requires x86 compilation: "Das Assembly zum Zugriff auf den SDD muss als X86 Assembly (32bit) kompiliert werden."

### Why No GUID Modification for Terminal Server?

The Windows ROT is already per-session on terminal servers. Each RDP session has its own ROT namespace. The bridge registers the BuddyAdapter with the unmodified base GUID (`D8CA0C15-8585-494A-93DF-07D706629793`), and Windows handles session isolation automatically.

### Why Suffix Phone Number Matching?

DATEV may store numbers without country code (`089/12345678`) while TAPI reports them with country code (`+498912345678`). Comparing only the last N digits (default: 10) normalizes away these differences.

### Why In-Memory Call History?

The call history is a circular buffer in process memory (no file I/O):

- Terminal server safe — no shared state between sessions
- No persistence needed — re-journaling is for recent calls only
- No file locking issues
- Configurable capacity (default: 5 per direction)

### Why Size-Based Log Rotation Only?

Time-based rotation adds complexity for minimal benefit. Size-based rotation (10 MB per file, 5 files max = 50 MB cap) is sufficient for diagnostics and prevents unbounded disk usage.

---

## File Structure

```
3CXDatevBridge/
├── Program.cs                          Entry point, single instance mutex
├── Core/
│   ├── BridgeService.cs                Central orchestrator (1,200 lines)
│   ├── BridgeStatus.cs                 Connection status enum
│   ├── CallTracker.cs                  Active/pending call management
│   ├── CallStateMachine.cs             TAPI state transition validation
│   ├── CallRecord.cs                   Call data record model
│   ├── CallIdGenerator.cs              {Ext}-{date}-{time}-{random} format
│   ├── CallHistoryEntry.cs             History entry for re-journal
│   ├── CallHistoryStore.cs             Circular buffer (in/out)
│   ├── ConfigKeys.cs                   INI key constants
│   ├── ContactRoutingCache.cs          Last-contact routing
│   ├── DebugConfigWatcher.cs           INI hot-reload (FileSystemWatcher)
│   ├── CircuitBreaker.cs               Circuit breaker pattern
│   ├── RetryHelper.cs                  Retry with exponential backoff
│   ├── SessionManager.cs               Terminal server detection
│   ├── ShortcutManager.cs              Keyboard shortcuts
│   ├── AutoStartManager.cs             HKCU Run key management
│   ├── CommandLineOptions.cs           CLI argument parser
│   ├── LogPrefixes.cs                  Structured log prefixes
│   ├── Config/
│   │   ├── AppConfig.cs                Configuration defaults & typed access
│   │   └── IniConfig.cs                INI file reader (Windows API)
│   ├── Constants/
│   │   └── IntegrationConstants.cs     TAPI/DATEV/timeout constants
│   └── Exceptions/
│       ├── TapiException.cs            TAPI error with category
│       └── DatevException.cs           DATEV error with category
├── Tapi/
│   ├── ITelephonyProvider.cs           Provider interface (2 implementations)
│   ├── TapiLineMonitor.cs             TAPI 2.x implementation
│   ├── PipeTelephonyProvider.cs        Named pipe implementation
│   ├── TapiPipeServer.cs              Low-level pipe I/O
│   ├── TapiConfigReader.cs            3CX TAPI INI auto-detection
│   ├── TapiMessage.cs                 Message parsing/encoding
│   ├── TapiCallState.cs               Call state definitions
│   └── TapiCommands.cs                Protocol command constants
├── Datev/
│   ├── DatevCache.cs                   Contact cache + phone lookup
│   ├── DatevConnectionChecker.cs       DATEV availability checks
│   ├── COMs/
│   │   ├── CallData.cs                 IDatevCtiData implementation
│   │   └── DatevAdapter.cs             COM adapter (ROT registration)
│   ├── Constants/
│   │   ├── CommonParameters.cs         Shared GUIDs and values
│   │   └── DatevDataSource.cs          DataSource string constants
│   ├── Enums/
│   │   └── DatevEventType.cs           DATEV event types (Dial, Drop)
│   ├── Managers/
│   │   ├── AdapterManager.cs           COM lifecycle (ROT register/unregister)
│   │   ├── CallDataManager.cs          Call data preparation
│   │   ├── DatevContactManager.cs      SDD contact loading (with retry)
│   │   ├── LogManager.cs              Structured logging + rotation
│   │   └── NotificationManager.cs      DATEV notifications (with circuit breaker)
│   ├── DatevData/                      XML deserialization models
│   └── PluginData/                     Contact models
├── Interop/
│   ├── Rot.cs                          Running Object Table P/Invoke
│   └── TapiInterop.cs                 TAPI 2.x P/Invoke
├── Extensions/
│   └── PhoneNumberNormalizer.cs        Phone normalization (compiled Regex)
└── UI/
    ├── TrayApplication.cs              System tray, menu, icon
    ├── UITheme.cs                      Dark theme, fonts, icon generation
    ├── [9 form files]                  WinForms UI
    ├── Strings/UIStrings.cs            German UI text
    └── Theme/
        ├── Layout.cs                   Layout constants
        └── DarkMenuRenderer.cs         Dark context menu renderer
```

---

## Building

1. Open `3CXDatevBridge.sln` in Visual Studio 2019 or later
2. Ensure DATEV DLLs are available in the GAC (install DATEV Simulator or DATEV Basis)
3. Ensure 3CX Multi-Line TAPI driver is installed for testing
4. Target: **x86** (required by DATEV SDK)
5. Build → Release
6. Output: `bin\Release\3cxDatevBridge.exe`

The project uses old-style `.csproj` with explicit `<Compile Include>` entries. When adding or removing files, update the `.csproj` accordingly.
