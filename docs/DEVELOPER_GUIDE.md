# 3CX - DATEV Connector — Developer Guide

## Why This Application Exists

3CX V20 migrated from WinForms/.NET Framework to WinUI 3/.NET 9.0 and **removed the legacy plugin system** (MyPhonePlugins). This broke all existing DATEV CTI integrations that relied on the plugin interface.

This standalone proxy application restores DATEV integration by:

1. Monitoring calls via the Windows **TAPI 2.x API** (the 3CX Multi-Line TAPI driver still exposes this)
2. Sending commands to 3CX via **Named Pipes** (the TAPI Service Provider's pipe interface)
3. Communicating with DATEV via the **COM/ROT Buddy interface** (unchanged since DATEV SDK 2022)

The connector is intentionally a separate process rather than a plugin because there is no plugin system to hook into.

---

## DATEV Buddy Interface

The connector implements the **DATEV CTI Buddy SDK** (version 16.02.2022). This is a COM-based interface defined in `DatevCtiBuddy.tlb`.

### Interface Map

| IDL Interface | Implemented By | Role |
|---------------|----------------|------|
| `IDatevCtiControl` | `DatevAdapter.cs` (Connector) | DATEV calls `Dial()` and `Drop()` on the connector |
| `IDatevCtiHistory` | `DatevAdapter.cs` (Connector) | DATEV calls `GetCallData()` (not used per spec) |
| `IDatevCtiNotification` | DATEV Telefonie | Connector calls `NewCall()`, `CallStateChanged()`, `CallAdressatChanged()`, `NewJournal()` |
| `IDatevCtiData` | Both sides | Data transfer object for call information (11 properties) |

### COM Class Registration (ROT)

Neither class is registered in the Windows registry. Both use the **Running Object Table** for discovery:

| Class | CLSID | Registered By |
|-------|-------|---------------|
| `DatevTelefonie` | `A299D197-E7C3-43E2-8ACC-C608FC2A7806` | DATEV Arbeitsplatz |
| `BuddyAdapter` | `D8CA0C15-8585-494A-93DF-07D706629793` | This connector (`AdapterManager.cs`) |

The connector registers `BuddyAdapter` in ROT at startup and removes it at shutdown. DATEV looks up the connector via `GetActiveObject()` with the BuddyAdapter CLSID.

### IDatevCtiData Properties

| ID | Property | Type | Notes |
|----|----------|------|-------|
| 1 | `CallID` | BSTR | Generated by bridge, never empty, unique per call |
| 2 | `SyncID` | BSTR | Set exclusively by DATEV, must not be stored in journal |
| 3 | `Direction` | ENUM_DIRECTION | `eDirIncoming` or `eDirOutgoing` |
| 4 | `Begin` | DATE | Call start time (Offered) or connect time (Connected/Finished) |
| 5 | `End` | DATE | Always >= Begin. Disconnect time when Finished |
| 6 | `CallState` | ENUM_CALLSTATE | `eCSOffered`, `eCSConnected`, `eCSFinished`, `eCSAbsence` |
| 7 | `Adressatenname` | BSTR | Contact display name |
| 8 | `AdressatenId` | BSTR | Contact ID from DATEV SDD |
| 9 | `DataSource` | BSTR | `DATEV_Adressaten`, `DATEV_Institutionen`, or `3CX` |
| 10 | `CalledNumber` | BSTR | Remote party's phone number (regardless of direction) |
| 11 | `Note` | BSTR | Call note (journal only) |

### CallState Transition Rules

The DATEV spec defines strict valid transitions:

```
Offered → Connected → Finished     (normal answered call)
Offered → Absence                   (missed/unanswered call)
Connected → Finished               (late-arriving call, already connected)
Finished                            (direct, for NewJournal)
Absence                             (direct, for NewJournal)
```

All other transitions are forbidden. The connector enforces this in `ConnectorService.cs` by mapping TAPI states to DATEV states:

| TAPI State | DATEV CallState | Notification |
|------------|----------------|--------------|
| `LINECALLSTATE_OFFERING` | `eCSOffered` | `NewCall()` |
| `LINECALLSTATE_RINGBACK` | `eCSOffered` | `NewCall()` (outgoing) |
| `LINECALLSTATE_CONNECTED` | `eCSConnected` | `CallStateChanged()` |
| `LINECALLSTATE_DISCONNECTED` (was connected) | `eCSFinished` | `CallStateChanged()` |
| `LINECALLSTATE_DISCONNECTED` (never connected) | `eCSAbsence` | `CallStateChanged()` |

### SyncID Contract

The SyncID is critical for DATEV's internal call tracking:

1. **Created exclusively by DATEV** — the bridge never generates a SyncID
2. **Passed via Dial command** — when DATEV initiates a call, SyncID is included
3. **Signaled back at every event** — NewCall, CallStateChanged, CallAdressatChanged all include SyncID
4. **Never stored in journal** — explicitly cleared (`SyncID = string.Empty`) before NewJournal
5. **Only valid during a call** — not persisted across calls

Implementation: `NotificationManager.cs:55` has an explicit comment: "Note: SyncID is NOT set by the bridge — only DATEV Telefonie sets this."

### DataSource Values

| Value | When to Use | Defined In |
|-------|-------------|------------|
| `DATEV_Adressaten` | Contact is a DATEV Recipient (from SDD KontaktDetail) | `DatevDataSource.Recipient` |
| `DATEV_Institutionen` | Contact is a DATEV Institution (from SDD TELEFONIE) | `DatevDataSource.Institution` |
| `3CX` | Contact is not in DATEV (unmatched caller) | `DatevDataSource.ThirdParty` |

Values starting with `DATEV_` are reserved by DATEV. The bridge uses `3CX` for unmatched callers.

---

## DATEV SDD Integration

### Contract Parameters

The bridge loads contacts from the DATEV Stammdatendienst (SDD) using these parameters:

**Recipients (Adressaten):**

```csharp
contractIdentifier = "Datev.Sdd.Contract.Browse.1.2"
dataEnvironment    = "Datev.DataEnvironment.Default"
elementName        = "KontaktDetail"
filterExpression   = @"<FilterExpression>
    <ComparisonExpression operator=""NOT EQUAL TO"">
        <LeftOperand><Field name=""@Status""/></LeftOperand>
        <RightOperand><Literal type=""String"" value=""0""/></RightOperand>
    </ComparisonExpression>
</FilterExpression>"   // only when ActiveContactsOnly=true
```

**Institutions:**

```csharp
contractIdentifier = "Datev.Inst.Contract.1.0"
dataEnvironment    = "Datev.DataEnvironment.Default"
elementName        = "TELEFONIE"
// no status filter
```

### XML Data Mapping

| XML Path | Maps To | Notes |
|----------|---------|-------|
| `KontaktDetail[@ID]` | `AdressatenId` | Not displayed, used as key |
| `KontaktDetail/Kontakt/Langname` | `Adressatenname` | Display name |
| `KontaktDetail/Kontakt/Kommunikationen/Kommunikation/Medium` | `Medium` enum | 1 = Phone (only type loaded) |
| `KontaktDetail/Kontakt/Kommunikationen/Kommunikation/Nummer` | `CalledNumber` | Phone number |
| `KontaktDetail/Kontakt/Kommunikationen/Kommunikation/Notiz` | (displayed in popup) | Phone number note |

The same structure applies to Institutions with `TELEFONIE` as the root element instead of `KontaktDetail`.

### Phone Filtering

Only communications with `Medium == 1` (Phone) are loaded. Email, fax, internet, and other medium types are filtered out in `DatevContactRepository` during contact loading. This reduces loaded objects from ~68,000 to ~17,000.

---

## Named Pipe Protocol

### Architecture

The connector is the pipe **server**. The 3CX Softphone connects as **client**.

```
3CX Softphone (Client)  ←→  Connector (Server)
                              \\.\pipe\3CX_tsp_server_{extension}
```

The 3CX Softphone polls for this pipe every ~2 seconds at startup. On Terminal Server, the pipe must be created before TAPI initialization.

### Wire Format

```
[2 bytes: message length (little-endian uint16)] [N bytes: UTF-16LE message body]
```

Example: A 20-character message has a 4-byte header (length=40 in LE) followed by 40 bytes of UTF-16LE text.

### Message Format

Messages are comma-separated `key=value` pairs:

```
__reqId=1,callid=123,cmd=MAKE-CALL,number=+49891234567
```

Reply pattern: The softphone echoes the original `cmd` with `__answ#` prefix and `reply` fields.

### Protocol Commands

| Direction | Command | Key Fields | Purpose |
|-----------|---------|------------|---------|
| Server→Client | `SRVHELLO` | `cmd` | Handshake initiation |
| Client→Server | `CLIHELLO` | `cmd` | Handshake response |
| Server→Client | `MAKE-CALL` | `cmd`, `number`, `__reqId` | Initiate outgoing call |
| Server→Client | `DROP-CALL` | `cmd`, `callid`, `__reqId` | Hang up active call |
| Client→Server | `RINGING` | `cmd`, `callid`, `callerid` | Incoming call notification |
| Client→Server | `RINGBACK` | `cmd`, `callid`, `callerid` | Outgoing call ringing |
| Client→Server | `CONNECTED` | `cmd`, `callid` | Call connected |
| Client→Server | `DISCONNECTED` | `cmd`, `callid` | Call ended |
| Client→Server | `CALL-INFO` | `cmd`, `callid`, various | Caller/called party info |

### Pipe Security

Access is controlled via Windows DACL on the `NamedPipeServerStream`:

- Current user's SID: `FullControl`
- `ALL APPLICATION PACKAGES` (SID `S-1-15-2-1`): `FullControl` (for MSIX/AppContainer 3CX apps)
- No other access

---

## Call Tracking

### CallID Generation

Format: `{Extension}-{ddMMyyyy}-{HHmm}-{Random7}`

Example: `161-04022026-1430-0912387`

The random suffix ensures uniqueness across restarts (no sequential counter).

Implementation: `CallIdGenerator.Next()` in `Core/CallIdGenerator.cs`.

### Call Record Lifecycle

```
1. OFFERING/RINGBACK
   └── CallTracker.AddCall(tapiCallId, isIncoming)
       └── Creates CallRecord with StartTime, Direction

2. Contact matched
   └── record.CallData populated with DATEV contact info
       └── NotificationManager.NewCall(callData)

3. CONNECTED
   └── record.ConnectTime = DateTime.Now
       └── NotificationManager.CallStateChanged(eCSConnected)

4. DISCONNECTED
   └── record.EndTime = DateTime.Now
       └── NotificationManager.CallStateChanged(eCSFinished or eCSAbsence)
       └── CallTracker.RemoveCall(tapiCallId)
       └── CallHistoryStore.Add(entry) if DATEV-matched
```

### Pending Calls (DATEV Dial)

When DATEV initiates a Dial command, the connector stores a "pending call" because the TAPI event hasn't arrived yet:

```
1. DATEV Dial received
   └── CallTracker.AddPendingCall(tempId)
       └── Store SyncID, contact info, phone number
       └── Update phone number index for matching

2. TAPI RINGBACK arrives
   └── CallTracker.FindPendingCallByNumber(normalizedNumber)
       └── Match by normalized phone number (O(1) via index)
       └── CallTracker.PromotePendingCall(tempId, tapiCallId)
           └── Pending call becomes active call with preserved DATEV context
```

### Stale Call Cleanup

A timer runs every 60 seconds to clean up stale calls:

- Active calls older than `StaleCallTimeoutMinutes` (default: 240 min) are removed
- Pending calls older than `StalePendingTimeoutSeconds` (default: 300 sec) are removed

---

## Contact Matching

### Normalization Pipeline

```
Input:  "+49 89 12345678"
Step 1: Strip international prefix: "+49" → "49"     → "49 89 12345678"
Step 2: Strip non-digits:                              → "498912345678"
Step 3: Take last MaxCompareLength digits (default 10): → "8912345678"
```

The same normalization is applied to both incoming caller IDs and DATEV contact phone numbers.

### Lookup Strategy

1. **Exact match** — O(1) lookup in `SortedDictionary<string, List<DatevContactInfo>>`
2. **Suffix match** — If no exact match, try suffix matching (min 6 digits overlap):
   - Incoming number ends with stored key (DATEV has shorter number)
   - Stored key ends with incoming number (incoming is shorter)
3. **No match** — Return empty list, DataSource set to `3CX`

### Last-Contact Routing

`ContactRoutingCache` remembers the last-selected contact per normalized phone number:

- On contact selection (initial or reshow), the choice is recorded
- On next call from the same number (within `LastContactRoutingMinutes`), the previous choice is prioritized
- Cache is in-memory only, resets on restart

---

## Error Handling Patterns

### Circuit Breaker

`CircuitBreaker.cs` wraps all DATEV COM calls:

```
Closed → (3 failures) → Open → (30s timeout) → Half-Open → (success) → Closed
                                                           → (failure) → Open
```

This prevents the connector from hanging on DATEV COM timeouts when DATEV is unavailable.

### Retry with Backoff

`RetryHelper.cs` provides retry logic for SDD operations:

- Attempt 1: Immediate
- Attempt 2: Wait `SddRetryDelaySeconds` (default 1s)
- Attempt 3: Wait `SddRetryDelaySeconds * 2` (default 2s)
- Only transient errors trigger retries

### TAPI Error Categories

`TapiInterop.cs` categorizes TAPI errors for intelligent handling:

| Category | Action | Examples |
|----------|--------|---------|
| `Success` | Continue | No error |
| `Transient` | Retry with backoff (500ms→1s→2s→4s) | REINIT, RESOURCEUNAVAIL |
| `LineClosed` | Reconnect line | INVALLINEHANDLE |
| `Shutdown` | Full reinitialize | NODRIVER, UNINITIALIZED |
| `Permanent` | Log and fail | INVALAPPHANDLE, OPERATIONFAILED |

---

## Terminal Server Considerations

### Per-Session Isolation

On terminal servers, multiple users run DATEV and the connector simultaneously. Isolation is provided by the OS:

| Resource | Isolation | Mechanism |
|----------|-----------|-----------|
| ROT | Per-session | Windows ROT is session-scoped (no GUID modification needed) |
| Named Pipe | Per-user | DACL restricts to current user's SID |
| TAPI | Per-session | Each session has its own TAPI driver instance |
| INI Config | Per-user | `%AppData%` resolves to per-user path |
| Log File | Per-user | Written to per-user `%AppData%` |

### Startup Order on Terminal Server

```
1. Connector creates Named Pipe server (MUST be first)
2. 3CX Softphone detects pipe (polls every ~2 seconds)
3. Connector initializes DATEV (ROT registration, SDD load)
4. 3CX connects to pipe → handshake (SRVHELLO/CLIHELLO)
5. TAPI events begin flowing
```

The pipe must exist before 3CX polls for it, which is why pipe creation happens before DATEV initialization on Terminal Server.

---

## Design Decisions

### Why TAPI 2.x Instead of Direct 3CX API?

3CX V20 has no public plugin API. The TAPI driver is the only stable interface for call monitoring. It provides reliable call state events without depending on 3CX internal APIs.

### Why Named Pipes Instead of TAPI MakeCall?

The TAPI `lineMakeCall` function can initiate calls, but the 3CX TAPI driver uses a named pipe for command dispatch. The bridge creates a pipe server matching the name 3CX expects (`3CX_tsp_server_{ext}`) and sends commands in the 3CX wire format.

### Why a Single ConnectorService Orchestrator?

At ~1,300 lines, `ConnectorService.cs` is large but serves as the single orchestration point. It exposes `StatusChanged` and `ModeChanged` events so UI forms can react immediately to connection and telephony mode changes. The domain logic is delegated to focused managers:

- `CallTracker` — call lifecycle
- `NotificationManager` — DATEV COM calls
- `CallDataManager` — data preparation
- `DatevContactRepository` — SDD access & contact lookup
- `CallStateMachine` — state validation

Splitting ConnectorService would mainly shuffle code and add inter-class communication without reducing complexity.

### Why COM/ROT Instead of REST/gRPC?

The DATEV Buddy interface is defined by DATEV as a COM/ROT-based interface. There is no alternative. Both DATEV and the connector register COM objects in the Running Object Table and discover each other via `GetActiveObject()`.

### Why .NET Framework 4.8 Instead of .NET 8+?

The DATEV COM interop libraries (`DATEV.Interop.DatevCtiBuddy.dll`) target .NET Framework. The SDD client libraries (`Datev.Sdd.Data.ClientInterfaces.dll`) are also .NET Framework assemblies. Mixing .NET Framework COM interop with .NET 8+ would require complex bridging.

### Why x86?

The DATEV SDK documentation requires x86 compilation: "Das Assembly zum Zugriff auf den SDD muss als X86 Assembly (32bit) kompiliert werden."

### Why No GUID Modification for Terminal Server?

The Windows ROT is already per-session on terminal servers. Each RDP session has its own ROT namespace. The bridge registers the BuddyAdapter with the unmodified base GUID (`D8CA0C15-8585-494A-93DF-07D706629793`), and Windows handles session isolation automatically.

### Why Suffix Phone Number Matching?

DATEV may store numbers without country code (`089/12345678`) while TAPI reports them with country code (`+498912345678`). Comparing only the last N digits (default: 10) normalizes away these differences.

### Why In-Memory Call History?

The call history is a circular buffer in process memory (no file I/O):

- Terminal server safe — no shared state between sessions
- No persistence needed — re-journaling is for recent calls only
- No file locking issues
- Configurable capacity (default: 5 per direction)

### Why Size-Based Log Rotation Only?

Time-based rotation adds complexity for minimal benefit. Size-based rotation (10 MB per file, 5 files max = 50 MB cap) is sufficient for diagnostics and prevents unbounded disk usage.

---

## File Structure

```
3CXDatevConnector/
├── Program.cs                          Entry point, single instance mutex
├── Core/
│   ├── ConnectorService.cs                Central orchestrator (~1,300 lines, events: StatusChanged, ModeChanged)
│   ├── ConnectorStatus.cs                 Connection status enum
│   ├── CallEventProcessor.cs           Call event processing logic
│   ├── CallTracker.cs                  Active/pending call management
│   ├── CallStateMachine.cs             TAPI state transition validation
│   ├── CallRecord.cs                   Call data record model
│   ├── CallIdGenerator.cs              {Ext}-{date}-{time}-{random} format
│   ├── CallHistoryEntry.cs             History entry for re-journal
│   ├── CallHistoryStore.cs             Circular buffer (in/out)
│   ├── ConfigKeys.cs                   INI key constants
│   ├── ContactRoutingCache.cs          Last-contact routing
│   ├── DatevCommandHandler.cs          DATEV command handling (Dial/Drop)
│   ├── DebugConfigWatcher.cs           INI hot-reload (FileSystemWatcher)
│   ├── EventHelper.cs                  Event helper utilities
│   ├── CircuitBreaker.cs               Circuit breaker pattern
│   ├── MemoryOptimizer.cs              GC and working set management
│   ├── RetryHelper.cs                  Retry with exponential backoff
│   ├── SessionManager.cs               Terminal server detection
│   ├── ShortcutManager.cs              Keyboard shortcuts
│   ├── AutoStartManager.cs             HKCU Run key management
│   ├── TelephonyMode.cs               Telephony mode enum
│   ├── TelephonyProviderSelector.cs   Auto-detection logic
│   ├── Config/
│   │   ├── AppConfig.cs                Configuration defaults & typed access
│   │   ├── ConfigParser.cs             Configuration parsing utilities
│   │   └── IniConfig.cs                INI file reader (Windows API)
├── Tapi/
│   ├── ITelephonyProvider.cs           Provider interface (3 implementations)
│   ├── TapiLineMonitor.cs             TAPI 2.x implementation
│   ├── PipeTelephonyProvider.cs        Named pipe implementation
│   ├── TapiPipeServer.cs              Low-level pipe I/O
│   ├── TapiConfigReader.cs            3CX TAPI INI auto-detection
│   ├── TapiMessage.cs                 Message parsing/encoding
│   ├── TapiCallState.cs               Call state definitions
│   └── TapiCommands.cs                Protocol command constants
├── Datev/
│   ├── DatevContactRepository.cs       Unified contact repo with lookup
│   ├── DatevContactDiagnostics.cs      Contact diagnostic utilities
│   ├── DatevConnectionChecker.cs       DATEV availability checks
│   ├── COMs/
│   │   ├── CallData.cs                 IDatevCtiData implementation
│   │   └── DatevAdapter.cs             COM adapter (ROT registration)
│   ├── Constants/
│   │   ├── CommonParameters.cs         Shared GUIDs and values
│   │   └── DatevDataSource.cs          DataSource string constants
│   ├── Enums/
│   │   └── DatevEventType.cs           DATEV event types (Dial, Drop)
│   ├── Managers/
│   │   ├── AdapterManager.cs           COM lifecycle (ROT register/unregister)
│   │   ├── CallDataManager.cs          Call data preparation
│   │   ├── LogManager.cs              Structured logging + rotation
│   │   └── NotificationManager.cs      DATEV notifications (with circuit breaker)
│   ├── DatevData/                      XML deserialization models
│   └── PluginData/                     Contact models
├── Webclient/
│   ├── Protocol.cs                    JSON protocol (v1) types & parser
│   ├── WebSocketBridgeServer.cs       WebSocket server (port 19800)
│   └── WebclientTelephonyProvider.cs  ITelephonyProvider for WebClient
├── Interop/
│   ├── Rot.cs                          Running Object Table P/Invoke
│   └── TapiInterop.cs                 TAPI 2.x P/Invoke
├── Extensions/
│   └── PhoneNumberNormalizer.cs        Phone normalization (compiled Regex)
└── UI/
    ├── TrayApplication.cs              System tray, menu, icon
    ├── UITheme.cs                      Dark theme, fonts, icon generation
    ├── [9 form files]                  WinForms UI
    ├── Strings/UIStrings.cs            German UI text
    └── Theme/
        ├── Layout.cs                   Layout constants
        └── DarkMenuRenderer.cs         Dark context menu renderer
```

---

## Building

1. Open `3CXDatevConnector.sln` in Visual Studio 2019 or later
2. Ensure DATEV DLLs are available in the GAC (install DATEV Simulator or DATEV Basis)
3. Ensure 3CX Multi-Line TAPI driver is installed for testing
4. Target: **x86** (required by DATEV SDK)
5. Build → Release
6. Output: `bin\Release\3cxDatevConnector.exe`

The project uses old-style `.csproj` with explicit `<Compile Include>` entries. When adding or removing files, update the `.csproj` accordingly.

---

## WebClient Mode (Browser Extension)

### Overview

The WebClient mode enables DATEV integration for users who use ONLY the 3CX Webclient (browser-based, WebRTC). No 3CX Windows application is required.

Call events are received from a browser extension (Chrome/Edge) via a direct WebSocket connection. The connector sends Dial/Drop commands back to the extension using the same channel.

### Architecture

```
3CX Server (wss protobuf)
        |
        v
3CX PWA (Browser)
        |
        | page-hook.js (WebSocket monkey-patch)
        v
content.js (content script, isolated world)
        |
        | chrome.runtime.sendMessage
        v
background.js (MV3 service worker)
        |
        | WebSocket ws://127.0.0.1:19800
        v
3CX - DATEV Connector (WebSocketBridgeServer)
        |
        | ITelephonyProvider events (TapiCallEvent)
        v
ConnectorService -> DATEV (COM/ROT)
```

The extension auto-detects the extension number from the 3CX PWA's `localStorage.wc.provision` and from protobuf `MyExtensionInfo` (MessageId 201). Provision data is persisted to `chrome.storage.local` to survive MV3 service worker restarts.

### Protocol (v1)

All messages are JSON with a `"v": 1` version field. Over WebSocket, messages are plain JSON text frames (no length prefix).

#### Extension -> Connector: HELLO

Sent by the extension after connecting. Must be the first message.

```json
{
  "v": 1,
  "type": "HELLO",
  "extension": "101",
  "identity": "3CX WebClient"
}
```

#### Connector -> Extension: HELLO_ACK

Sent after receiving HELLO. Indicates the connector is ready.

```json
{
  "v": 1,
  "type": "HELLO_ACK",
  "bridgeVersion": "1.0",
  "extension": "101",
  "ready": true
}
```

#### Extension -> Bridge: CALL_EVENT

Sent for each call state change.

```json
{
  "v": 1,
  "type": "CALL_EVENT",
  "ts": 1730000000000,
  "call": {
    "id": "webcall-abc123",
    "direction": "inbound",
    "remoteNumber": "+49891234567",
    "remoteName": "Max Mustermann",
    "state": "offered",
    "reason": ""
  },
  "context": {
    "extension": "101",
    "tabId": "tab-42"
  }
}
```

**Call states:**
| Extension State | TAPI Mapping | DATEV Result |
|----------------|--------------|--------------|
| `offered` (inbound) | `LINECALLSTATE_OFFERING` | NewCall(eCSOffered, eDirIncoming) |
| `dialing` (outbound) | `LINECALLSTATE_RINGBACK` | NewCall(eCSOffered, eDirOutgoing) |
| `ringing` (outbound) | `LINECALLSTATE_RINGBACK` | NewCall(eCSOffered, eDirOutgoing) |
| `connected` | `LINECALLSTATE_CONNECTED` | CallStateChanged(eCSConnected) |
| `ended` (was connected) | `LINECALLSTATE_DISCONNECTED` | CallStateChanged(eCSFinished) |
| `ended` (never connected) | `LINECALLSTATE_DISCONNECTED` | CallStateChanged(eCSAbsence) |

**End reasons:** `hangup`, `busy`, `failed`, `unknown`

#### Connector -> Extension: COMMAND

```json
{
  "v": 1,
  "type": "COMMAND",
  "cmd": "DIAL",
  "number": "+49891234567",
  "context": { "syncId": "optional-datev-syncid" }
}
```

```json
{
  "v": 1,
  "type": "COMMAND",
  "cmd": "DROP",
  "callId": "webcall-abc123"
}
```

### Files

| File | Purpose |
|------|---------|
| `Webclient/Protocol.cs` | Message types, constants, JSON parser |
| `Webclient/WebSocketBridgeServer.cs` | WebSocket server (port 19800) |
| `Webclient/WebclientTelephonyProvider.cs` | ITelephonyProvider implementation |

### Browser Extension

The MV3 browser extension in `Extension/` performs:

- `page-hook.js` — Monkey-patches `window.WebSocket` to intercept the 3CX `wss://` connection; posts binary frames (base64) and text frames to the content script
- `content.js` — Relays page-hook signals to the service worker; reads `localStorage.wc.provision` to auto-detect extension number; detects 3CX pages via path, hash route, or localStorage presence
- `background.js` — Connects to bridge via `ws://127.0.0.1:19800`; decodes protobuf `GenericMessage` + `MyExtensionInfo` (MessageId 201); maps `LocalConnection` deltas to bridge `CALL_EVENT` messages; persists provision to `chrome.storage.local`; responds to `GET_STATUS` messages from popup with `{ wsState, helloAcked, extension }`
- `popup.html` / `popup.js` — Dark-themed extension popup matching main app (`#2D2D30` background). Shows live WebSocket connection status (green/yellow/red dot), bold extension number, DATEV Auto-DIAL delay input, Save and Reload buttons

If 3CX changes protobuf field numbers in future builds, adjust parser mappings in
`Extension/scripts/background.js` (`parseGenericMessage`, `parseMyExtensionInfo`,
`parseLocalConnection`).

### Auto-Detection: TryAcceptAsync Loop

During auto-detection (`TelephonyMode=Auto`), the WebSocket server's `TryAcceptAsync` method accepts connections in a loop within the configured timeout. This is necessary because the browser extension sends an HTTP probe (plain GET request) before the real WebSocket upgrade. The loop handles this by:

1. Accepting a TCP connection
2. Attempting the WebSocket handshake
3. If the handshake fails (HTTP probe), closing the connection and accepting the next one
4. If the handshake succeeds, waiting for the HELLO message within the remaining timeout

This ensures auto-detection works reliably even when the browser extension probes the port before establishing the real WebSocket connection.

### Disconnect Propagation

When the browser extension disconnects (e.g., tab closed, browser closed), the `WebclientTelephonyProvider` fires both `LineDisconnected` and the provider-level `Disconnected` event. This ensures:

- `ConnectorService.Status` transitions to `Disconnected`
- `StatusChanged` event fires, updating all subscribed UI forms (StatusForm, SettingsForm, tray icon)
- Tray balloon notification is shown (if notifications are enabled)
- The provider enters its reconnect loop, waiting for the extension to reconnect

### Troubleshooting

| Symptom | Cause | Fix |
|---------|-------|-----|
| "Warte auf Browser-Erweiterung" | Extension not installed or not connected | Install extension, check bridge is running on port 19800 |
| Extension connects but no HELLO | Protocol version mismatch | Verify extension sends `"v": 1` and `"type": "HELLO"` |
| HELLO has empty extension | Content script not injected or PWA not detected | Check `localStorage.wc.provision` exists; reload extension |
| Calls not appearing in DATEV | State mapping issue | Check logs for "WebClient Connector" entries |
| Timeout during auto-detection | Extension takes too long | Increase `Webclient.ConnectTimeoutSec` in INI |
| Auto-detection fails with "Handshake failed" | Browser extension HTTP probe consumed the connection | Fixed in current version — `TryAcceptAsync` loops to handle probes |
| UI not updating on extension disconnect | Missing disconnect event propagation | Fixed in current version — `OnTransportDisconnected` fires both `LineDisconnected` and `Disconnected` |

---

## Auto Detection

### Overview

When `TelephonyMode = Auto` (default), the connector attempts to detect the best available telephony provider at startup.

### Detection Order

| Priority | Provider | Detection Method | Success Criteria |
|----------|----------|-----------------|-----------------|
| A | **WebClient** | Start pipe listener, wait for extension HELLO | Extension connects and sends HELLO within `Webclient.ConnectTimeoutSec` |
| B | **Pipe** | Check `SessionManager.IsTerminalSession` and pipe availability | Running in a terminal server session |
| C | **TAPI** | Default fallback for desktop environments | Desktop environment detected |
| D | **None** | All detection methods failed | Setup Wizard is shown |

### Configuration Keys

| Key | Default | Description |
|-----|---------|-------------|
| `TelephonyMode` | `Auto` | `Auto`, `Tapi`, `Pipe`, or `WebClient` |
| `Auto.DetectionTimeoutSec` | `10` | Total timeout for auto-detection |
| `Webclient.ConnectTimeoutSec` | `8` | How long to wait for browser extension |
| `Webclient.Enabled` | `true` | Enable/disable Webclient detection in Auto mode |
| `Webclient.WebSocketPort` | `19800` | WebSocket port for browser extension connection |

### Explicit Mode

When `TelephonyMode` is explicitly set to `Tapi`, `Pipe`, or `WebClient`, only that provider is used. If it fails to start, the connector logs a guided error.

### Diagnostic Logs

During auto-detection, the connector logs a diagnostic summary:

```
TelephonyProviderSelector: Auto-detection starting (timeout=10s)
TelephonyProviderSelector: [A] Trying WebClient (timeout=8s)
TelephonyProviderSelector: [A] WebClient not detected
TelephonyProviderSelector: [B] Trying Pipe
TelephonyProviderSelector: [B] Pipe not applicable
TelephonyProviderSelector: [C] Trying TAPI
TelephonyProviderSelector: TAPI selected - Desktop environment
TelephonyMode chosen: Tapi (reason: Desktop environment - using TAPI)
```

### Console Test Mode

A developer-only console mode is available for testing the Webclient provider:

```
3CXDatevConnector.exe --test-webclient [extension]
```

This reads JSON CALL_EVENT lines from stdin and logs the DATEV notifications that would be emitted.

**Example JSON traces:**

Inbound missed call:
```json
{"v":1,"type":"CALL_EVENT","ts":1700000001,"call":{"id":"c1","direction":"inbound","remoteNumber":"+49891111111","state":"offered"}}
{"v":1,"type":"CALL_EVENT","ts":1700000010,"call":{"id":"c1","direction":"inbound","remoteNumber":"+49891111111","state":"ended","reason":"unknown"}}
```

Inbound answered call:
```json
{"v":1,"type":"CALL_EVENT","ts":1700000001,"call":{"id":"c2","direction":"inbound","remoteNumber":"+49892222222","state":"offered"}}
{"v":1,"type":"CALL_EVENT","ts":1700000005,"call":{"id":"c2","direction":"inbound","remoteNumber":"+49892222222","state":"connected"}}
{"v":1,"type":"CALL_EVENT","ts":1700000060,"call":{"id":"c2","direction":"inbound","remoteNumber":"+49892222222","state":"ended","reason":"hangup"}}
```

Outbound answered call:
```json
{"v":1,"type":"CALL_EVENT","ts":1700000001,"call":{"id":"c3","direction":"outbound","remoteNumber":"+49893333333","state":"dialing"}}
{"v":1,"type":"CALL_EVENT","ts":1700000005,"call":{"id":"c3","direction":"outbound","remoteNumber":"+49893333333","state":"connected"}}
{"v":1,"type":"CALL_EVENT","ts":1700000120,"call":{"id":"c3","direction":"outbound","remoteNumber":"+49893333333","state":"ended","reason":"hangup"}}
```

Outbound no-answer (absence):
```json
{"v":1,"type":"CALL_EVENT","ts":1700000001,"call":{"id":"c4","direction":"outbound","remoteNumber":"+49894444444","state":"dialing"}}
{"v":1,"type":"CALL_EVENT","ts":1700000030,"call":{"id":"c4","direction":"outbound","remoteNumber":"+49894444444","state":"ended","reason":"unknown"}}
```

---

## 3CX WebClient Protocol Internals

This section documents the internal signaling protocol of the 3CX Webclient, reverse-engineered from the 3CX PWA's main bundle. This knowledge is needed to build the browser extension that intercepts call events.

### Transport

The 3CX Webclient communicates with the PBX over a single **WebSocket** connection:

```
wss://<host>/ws/webclient?sessionId=<key>&pass=<pass>
```

- Binary mode (`binaryType = "arraybuffer"`)
- Messages are **Protobuf-encoded** `GenericMessage` objects
- Each `GenericMessage` has a `MessageId` (uint32) that determines its type
- 150+ distinct message types (MessageId 1–564)

### Two Parallel Signaling Layers

The 3CX Webclient uses **two independent layers** for call handling:

| Layer | MessageId | Key Structure | Purpose |
|-------|-----------|---------------|---------|
| **Call Control** | 201 (`MyExtensionInfo`) | `LocalConnection` | Logical call state, direction, party info |
| **WebRTC SDP** | 227 (`MyWebRTCEndpoint`) | `WebRTCCall` | Media negotiation (SDP offer/answer/ICE) |

**The browser extension should intercept the Call Control layer (MessageId 201).** It provides everything needed for DATEV integration directly — call direction, remote party number/name, and clean state transitions — without needing to infer from SDP negotiation.

### Call Control Layer: MyExtensionInfo (MessageId 201)

`MyExtensionInfo` is the primary message for the user's own extension state. It is sent by the PBX whenever the user's call state changes.

**Key fields:**

| Field | Type | Description |
|-------|------|-------------|
| `Connections` | `LocalConnection[]` | Active calls on the user's extension |
| `OtherConnections` | `LocalConnection[]` | Calls visible but on other extensions |
| `CurrentStatus` | enum | User's presence status |
| `IsBusy` | bool | Whether the user is on a call |
| `IsRinging` | bool | Whether the extension is ringing |
| `MissedCallsCount` | int | Number of missed calls |
| `MyCalls` | `CallLogEntry[]` | Recent call history |

### LocalConnection — The Key Structure

Each active call is represented as a `LocalConnection`:

```
LocalConnection {
  Id:                    int       // Unique connection ID (per-call)
  CallId:                int       // Correlates with WebRTC layer
  State:                 enum      // LocalConnectionState (see below)
  IsIncoming:            bool      // true = inbound, false = outbound
  OtherPartyDn:          string    // Remote party phone number (DN)
  OtherPartyDisplayName: string    // Remote party display name
  OriginatorDn:          string    // Who initiated the call
  StartedAt:             DateTime  // When the call started (ring)
  AnsweredAt:            DateTime  // When the call was answered
  Recording:             bool      // Whether the call is being recorded
  CallCapabilitiesMask:  int       // Bitmask of allowed actions
}
```

### LocalConnectionState Enum

```
UnknownState        = 0
Ringing             = 1    // Inbound: extension is ringing
Dialing             = 2    // Outbound: dialing the remote party
Connected           = 3    // Call is active (both parties talking)
WaitingForNewParty  = 4    // Transfer: waiting for transfer target
TryingToTransfer    = 5    // Transfer: attempting to complete transfer
```

### ActionType Enum

LocalConnection updates within `MyExtensionInfo` are tagged with an `ActionType`:

```
NoUpdates  = 0    // No change
FullUpdate = 1    // Complete snapshot of all connections
Inserted   = 2    // New call appeared (ring/dial start)
Updated    = 3    // Existing call changed state
Deleted    = 4    // Call ended (removed from active list)
```

### ConnectionCapabilities Bitmask

```
CC_Drop     = 1    // Can hang up
CC_Divert   = 2    // Can divert/forward
CC_Transfer = 4    // Can transfer
CC_Pickup   = 8    // Can pick up
CC_BargeIn  = 16   // Can barge in
```

### Call Lifecycle in LocalConnection

**Inbound call (answered):**
```
1. MyExtensionInfo update: LocalConnection Inserted
     State=Ringing, IsIncoming=true, OtherPartyDn="0891234567"
2. MyExtensionInfo update: LocalConnection Updated
     State=Connected, AnsweredAt set
3. MyExtensionInfo update: LocalConnection Deleted
     (call ended)
```

**Outbound call (answered):**
```
1. MyExtensionInfo update: LocalConnection Inserted
     State=Dialing, IsIncoming=false, OtherPartyDn="0897654321"
2. MyExtensionInfo update: LocalConnection Updated
     State=Connected, AnsweredAt set
3. MyExtensionInfo update: LocalConnection Deleted
     (call ended)
```

**Inbound call (missed):**
```
1. MyExtensionInfo update: LocalConnection Inserted
     State=Ringing, IsIncoming=true, OtherPartyDn="0891234567"
2. MyExtensionInfo update: LocalConnection Deleted
     (caller hung up before answer)
```

### State Mapping: 3CX Internal → Connector Protocol → TAPI → DATEV

| 3CX LocalConnectionState | ActionType | Connector Protocol | TAPI Constant | DATEV |
|--------------------------|------------|----------------|---------------|-------|
| Ringing (1) + IsIncoming=true | Inserted | `offered` | LINECALLSTATE_OFFERING (0x02) | NewCall(eCSOffered, eDirIncoming) |
| Dialing (2) + IsIncoming=false | Inserted | `dialing` | LINECALLSTATE_RINGBACK (0x20) | NewCall(eCSOffered, eDirOutgoing) |
| Connected (3) | Updated | `connected` | LINECALLSTATE_CONNECTED (0x100) | CallStateChanged(eCSConnected) |
| *(any)* | Deleted | `ended` | LINECALLSTATE_DISCONNECTED (0x4000) | CallStateChanged(eCSFinished/eCSAbsence) |

### Call Control Commands

The extension can also send commands to the PBX for outbound dialing and call control:

| Command | MessageId | Key Fields |
|---------|-----------|------------|
| `RequestMakeCall` | 119 | `Destination` (string), `DeviceID` (string), `EnableCallControl` (bool) |
| `RequestDropCall` | 115 | `LocalConnectionId` (int), `IsLocal` (bool), `ActionIfRinging` (RejectAction enum) |
| `RequestPickupCall` | 117 | `LocalConnectionId` (int), `DeviceID` (string), `EnableCallControl` (bool) |
| `RequestTransferCall` | 118 | `LocalConnectionId` (int), `Destination` (string) |

### RejectAction Enum (for RequestDropCall)

```
RA_Terminate = 0    // Normal hangup
RA_Busy      = 1    // Reject with busy signal
RA_NoAnswer  = 2    // Reject as no-answer
```

### CallState Enum (from GenericMessage)

A higher-level call state also exists on MyCalls entries:

```
Unknown      = 0
Initiating   = 1
Routing      = 2
Talking      = 3
Transferring = 4
Rerouting    = 5
```

### WebRTC SDP Layer: MyWebRTCEndpoint (MessageId 227)

This layer handles media negotiation and is NOT needed for call state tracking, but is documented here for completeness.

**WebRTCCall structure:**

| Field | Type | Description |
|-------|------|-------------|
| `Action` | enum | SDP action type |
| `Id` | int | Call ID (correlates with LocalConnection.CallId) |
| `sdpType` | enum | WebRTCEndpointSDPState |
| `otherPartyNumber` | string | Remote party number |
| `otherPartyDisplayname` | string | Remote party name |
| `SIPDialogID` | string | SIP dialog identifier |
| `holdState` | enum | WebRTCHoldState |

**WebRTCEndpointSDPState enum:**

```
WRTCTerminate         = 0    // Call ended
WRTCOffer             = 1    // SDP offer (inbound)
WRTCAnswer            = 2    // SDP answer
WRTCConfirmed         = 3    // Media confirmed
WRTCRequestForOffer   = 4    // Request SDP offer (outbound)
WRTCOfferToConfirm    = 5    // Offer awaiting confirmation
WRTCReOffer           = 6    // Re-negotiate media
WRTCReOfferAnswer     = 7    // Answer to re-offer
WRTCReOfferConfirmed  = 8    // Re-offer confirmed
WRTCReOfferRequested  = 9    // Re-offer requested
WRTCInitial           = 10   // Initial state
```

**WebRTCHoldState enum:**

```
None       = 0    // Not on hold
Local      = 1    // Locally held
Remote     = 2    // Remotely held
Both       = 3    // Both sides held
```

### Browser Extension Architecture

Based on these findings, the browser extension should:

1. **Intercept the WebSocket** — Hook the `wss://{host}/ws/webclient` connection using a content script or background service worker that wraps `WebSocket.prototype.send` and the `onmessage` handler
2. **Decode Protobuf** — Parse `GenericMessage` binary frames to extract `MessageId` and payload
3. **Filter for MessageId 201** — Only process `MyExtensionInfo` updates
4. **Track LocalConnection changes** — Watch the `ActionType` on each connection:
   - `Inserted (2)` → new call, emit `CALL_EVENT` with state `offered` (inbound) or `dialing` (outbound)
   - `Updated (3)` + State=Connected → emit `CALL_EVENT` with state `connected`
   - `Deleted (4)` → call ended, emit `CALL_EVENT` with state `ended`
5. **Relay via WebSocket** — Send our JSON protocol to the bridge via `ws://127.0.0.1:19800`
6. **Receive commands** — Listen for DIAL/DROP commands from the bridge and construct the corresponding `RequestMakeCall` (MessageId 119) / `RequestDropCall` (MessageId 115) protobuf messages to inject into the WebSocket

### Key Insight: Why LocalConnection Over WebRTC SDP

| Criterion | LocalConnection (MessageId 201) | WebRTC SDP (MessageId 227) |
|-----------|--------------------------------|---------------------------|
| Call direction | `IsIncoming` boolean | Must infer from WRTCOffer vs WRTCRequestForOffer |
| Remote party number | `OtherPartyDn` field | `otherPartyNumber` field (available but less reliable) |
| Remote party name | `OtherPartyDisplayName` field | `otherPartyDisplayname` field |
| State clarity | Clean enum: Ringing, Dialing, Connected | 11-value SDP state enum requires complex mapping |
| Call timing | `StartedAt`, `AnsweredAt` | Not available directly |
| Call end detection | `Deleted` action type | WRTCTerminate (can fire for re-negotiations too) |
| Transfer support | WaitingForNewParty, TryingToTransfer | Not visible |

The LocalConnection layer is strictly superior for our use case.
